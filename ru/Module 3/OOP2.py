# Занятие 10 - различия переменных и методов в классах, продолжение изучения ООП

# Иногда нам нужно, чтобы посторонние не могли использовать параметры класса - изменять их по ходу программы
# или наоборот - нужно использовать метод, который никак не использует переменные класса, но связан с ним


# Предположим, нам нужно сделать аккаунт для пользователей банка,
# которые смогут менять свое имя и выполнять транзакции на своем счете
from random import choice  # для создания случайного id пользователям

ids: list[int] = list(range(1, 101))  # максимум 100 пользователей, у каждого уникальный id


class BankUser:
    # Это будет главный класс, который будет иметь несколько переменных
    name: str = "Публичная переменная"  # такую переменную можно использовать где угодно и как угодно
    _id: int = "Защищенная переменная"  # переменная недоступна у объектов, но доступна при наследовании
    __money: int = "Приватная переменная"  # переменная конкретно для этого класса, ее никак не изменить извне

    def __init__(self, name: str, money: int):
        """Пользователь в системе банка\n
        :param name имя пользователя\n
        :param money начальное кол-во денег на счету пользователя
        """
        global ids

        self.name = name
        self.__money = money

        self._id = choice(ids)  # даем уникальный номер id пользователю
        ids.remove(self._id)  # и сразу удаляем номер из списка доступных

    @staticmethod  # статичный метод - он не использует никакие переменные из класса,
    # но так как он связан с классом, можно добавить его тут
    def report_warning(warning: int) -> None:
        """Вывод ошибки в случае проблемы с программой"""
        match warning:
            case 1: print("Ошибка транзакции: на счету недостаточно денег для снятия")
            case 2: print("Ошибка: попытка взлома системы")
            case _: print("Ошибка: неизвестная ошибка")

    def increase_money(self, x: int) -> None:
        """Пополняем деньги на счете"""
        self.__money += x

    def decrease_money(self, x: int) -> None:
        """Снятие денег со счёта"""
        if self.__money < x:
            self.report_warning(1)
        else:
            self.__money -= x

    def get_money(self) -> int:
        """Возвращаем кол-во денег на балансе"""
        return self.__money


# Теперь у нас есть класс, в котором мы можем менять имя, но не можем изменить кол-во денег на балансе
andrey: BankUser = BankUser("Андрей", 100)

andrey.name = "Не Андрей"  # так можно

try:
    andrey.__money += 9999  # Тут будет ошибка, так как мы пытаемся изменить приватную переменную
    andrey._id = 0  # Тут тоже будет ошибка, так как изменение защищенной переменной также невозможно
except AttributeError:
    andrey.report_warning(2)

print(andrey.get_money())  # Зато мы можем также узнать свой баланс - для этого мы создали метод


# Теперь улучшим нашу программу - добавим автоматическую установку пола
class MaleBankUser(BankUser):
    # В этом классе нам даны переменные "_id" и "name"
    # "name" - публичная переменная, поэтому она наследовалась без проблем
    # "_id" - защищенная переменная, ее нельзя менять у объектов, но при этом такая переменная тоже наследуется

    _sex: str = "Тоже защищенная переменная"  # Если вдруг мы захотим потом создать еще более усложненный класс

    def __init__(self, name: str, money: int):
        """Пользователь - мужчина\n
        :param name имя пользователя\n
        :param money кол-во денег на счету у пользователя с самого начала"""
        # достаточно добавить 1 параметр в конструктор, поэтому тут просто вызовем конструктор высшего класса
        super().__init__(name, money)
        self._sex = "male"

    # мы можем использовать методы, связанные с деньгами, но не можем никак создать новые методы, так как у этого класса
    # нет доступа к переменной __money


# переменная может быть типа BankUser, так как мы использовали наследование
# формально классы - "родственники", значит не страшно, если тип немного отличается
# однако нельзя сделать переменную типа MaleBankUser, которая является объектом BankUser, типизация без ошибок работает
# только в сторону "родителей" типа
timofei: BankUser = MaleBankUser("Тимофей", 100)

try:  # ничего из этих 3 команд ниже мы использовать не можем, так как это защищенные или приватные переменные
    timofei.__money = 9990
    timofei._id = 0
    timofei._sex = "female"
except AttributeError:
    timofei.report_warning(2)

print(timofei.get_money())  # зато можем продолжить выполнять транзакции
