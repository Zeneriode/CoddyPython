# Файл, содержащий всю основную информацию по Python

# В этом языке есть 4 основных типа переменных

a = "1.0"  # "1.0" - строки
a = float(a)  # 1.0 - рациональное число (число с десятичной дробью)
a = bool(a)  # True - булево значение - Правда или Ложь
a = int(a)  # 1 - целое число (без дроби)

# Мы можем сравнивать наши переменные и значения, используя if или match (последнее только с версии 3.10)

# конструкция if - elif - else
if a == 1:  # пишем само условие
    pass
elif a > 0:  # если есть другой определенный случай, пишем сюда
    pass
else:  # если ничего не подходит, выполняем самое последнее
    pass

# конструкция match
match a:
    case 1: print("a = 1")  # если 'a' == 1, напишем это
    case 2: print("a = 2")  # если первый case не сработал, переходим к следующему
    case _: print("a != 1 или 2")  # аналог else

# Чтобы хранить несколько значений вместе, мы используем массивы
aa = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  # простой список
# у списков есть срезы - куски полного списка
aa = aa[:10]  # срез цикла до элемента с индексом 9 - удаляем элементы, начиная с 9 индекса
aa = aa[0:]  # срез цикла с элемента с индексом 0
aa = aa[0:10]  # срез цикла от элемента с индексом 0 до элемента с индексом 9
aa = aa[::-1]  # Разворот цикла - то есть будет 10, 9, 8 ... 1
aa = aa[0:10:1]  # от минимального элемента к максимальному с интервалом

# СТРОКИ - ЭТО СПИСКИ ДЛЯ КОМПЬЮТЕРА, С НИМИ МОЖНО РАБОТАТЬ ТАКЖЕ

aaa = {1: 0, 2: 'a', 5: 'g'}  # словарь - список, где индексы задаем мы сами
aaa = aaa[1]  # aaa = 0

a4 = (1, 2, 3, 4, 5)  # множество - список, который нельзя изменить
# кортеж не изменяется, можно максимум добавить новые значения

# Чтобы повторять действие, нужно использовать цикл.
# Цикл for - повторяет действие 'а' кол-во раз
for i in range(0, a, 1):  # минимальное число -> максимальное число +1 -> интервал между значениями
    pass  # 1 итерация (проход по циклу)

# цикл while - повторение действие, пока выполняется условие
while a >= 1:  # мы не меняем a внутри цикла, поэтому цикл будет идти бесконечно или не идти вообще
    pass  # команда-затычка, помогает запустить код без ошибки и при этом ничего не делать там, где пока ничего не надо


# функция - код, который повторяется в разных местах и/или с разными типами переменных
def find_b(b: int) -> int:  # функция принимает изначально 1 аргумент int (желательно) и возвращает int
    return b  # просто возвращает значение - вместо функции, где мы ее вызываем, будет выведено значение переменной b


n = int(input())  # принимаем значение от пользователя из консоли
print(find_b(n))  # выводим результат функции, используя переменную, введенную до этого нами


# рекурсия - функция, которая вызывает саму себя
def small_c(c: int) -> int:
    if c == 0:  # в рекурсии минимум 2 return - 1 для возврата константы, второй для возврата этой же функции
        return 1  # возвращаем константу

    c -= 1  # делаем какие-то действия
    return small_c(c)  # функция вызывает саму себя (параметр уже изменен), а потом возвращает значение


# пользователи могут поймать ошибку, которую мы можем заранее ловить, используя конструкцию try - except - finally
try:  # ловим ошибку
    print(1 / 0)  # пишем код, где мы ждем ошибку
except ZeroDivisionError:  # если мы поймали ошибку (может быть конкретная ошибка, как в примере)
    pass  # делаем что-то после поимки ошибки
finally:  # если не поймали ошибку, но при этом не можем продолжить без нее, начинает выполняться код из 'finally'
    ...  # аналог 'pass', тоже ничего не происходит


# Python поддерживает ООП, поэтому для упрощения разработки большого проекта можно использовать возможности парадигмы
# Это простой класс с конструктором
class Animal:
    x1 = 4  # публичная переменная - можно использовать когда и где угодно
    _x2 = 1  # protected переменная - можно использовать только в этом классе и в подклассах
    __x3 = 10  # приватная переменная - можно использовать только внутри класса

    def __init__(self, color, voice):  # конструктор, где мы инициализируем аргументы
        self.color = color  # какие-то параметры, нужные для будущего
        self.voice = voice  # это не статичные переменные, статичные находятся вне метода (то есть x1, _x2 и __x3)


# Подкласс - ребенок класса - обладает таким же конструктором по стандарту, может использовать все методы высшего класса
class Tiger(Animal):
    # __init__ заново создавать не надо, если нам не нужны новые параметры для этого класса

    def attack(self):  # Можно создать метод, которого нет у "Animal"
        self.voice += "RRR"  # И при этом мы используем старые параметры, которые достались нам от "Animal"


# чтобы при импорте в других файлах ничего не запустилось отсюда, мы будем проверять место запуска
if __name__ == "__main__":  # если мы хотим запустить конкретно этот файл, проверяем, что внутреннее имя файла __main__
    ...
